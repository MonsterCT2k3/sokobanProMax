package com.example.myapplication

import android.content.Context
import android.graphics.Canvas
import android.util.AttributeSet
import android.view.MotionEvent
import android.view.View
import com.example.myapplication.game.GameLogic
import com.example.myapplication.game.PlayerDirection
import com.example.myapplication.input.InputHandler
import com.example.myapplication.managers.SoundManager
import com.example.myapplication.rendering.BackgroundManager
import com.example.myapplication.rendering.GameRenderer
import com.example.myapplication.systems.BulletSystem
import com.example.myapplication.systems.MonsterSystem

/**
 * üéÆ GameView - Main game view class
 * 
 * ƒê√¢y l√† l·ªõp ch√≠nh qu·∫£n l√Ω to√†n b·ªô game Sokoban.
 * N√≥ ho·∫°t ƒë·ªông nh∆∞ m·ªôt coordinator, ƒëi·ªÅu ph·ªëi c√°c component:
 * - GameLogic: X·ª≠ l√Ω logic game (di chuy·ªÉn, win condition)
 * - GameRenderer: V·∫Ω game board v√† UI
 * - BackgroundManager: Qu·∫£n l√Ω background animation
 * - InputHandler: X·ª≠ l√Ω touch input v√† swipe gestures
 * 
 * @param context Android context
 * @param attrs XML attributes
 * @param defStyleAttr Default style attributes
 */
class GameView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr),
    GameLogic.GameStateListener,        // L·∫Øng nghe thay ƒë·ªïi tr·∫°ng th√°i game
    InputHandler.PlayerMoveListener {   // L·∫Øng nghe input t·ª´ user

    // ===== CORE COMPONENTS =====
    // M·ªói component c√≥ nhi·ªám v·ª• ri√™ng bi·ªát, t√°ch bi·ªát tr√°ch nhi·ªám
    private val gameLogic = GameLogic()                    // üéØ X·ª≠ l√Ω logic game
    private val gameRenderer = GameRenderer(context)       // üñºÔ∏è V·∫Ω game board v√† UI
    private val backgroundManager = BackgroundManager(context) // üé® Qu·∫£n l√Ω background
    private val inputHandler = InputHandler()              // üëÜ X·ª≠ l√Ω touch input
    private val monsterSystem = MonsterSystem()            // üëæ X·ª≠ l√Ω logic monster
    private val bulletSystem = BulletSystem()               // üéØ X·ª≠ l√Ω logic bullet
    private val soundManager = SoundManager(context)

    // ===== GAME THREAD MANAGEMENT =====
    // Game ch·∫°y tr√™n thread ri√™ng ƒë·ªÉ kh√¥ng block UI thread
    private var gameThread: Thread? = null                 // Thread ch·∫°y game loop
    private var isGameRunning = false                      // Tr·∫°ng th√°i game ƒëang ch·∫°y
    private var targetFPS = 60                             // M·ª•c ti√™u 60 FPS
    private var frameTimeMillis = 1000L / targetFPS        // Th·ªùi gian m·ªói frame (‚âà16.67ms)
    private var gameStateChanged = false                   // Flag b√°o c·∫ßn redraw
    private var frameCount = 0                             // ƒê·∫øm frame ƒë·ªÉ t√≠nh FPS
    private var lastFPSTime = 0L                           // Th·ªùi gian l·∫ßn cu·ªëi t√≠nh FPS
    
    // ===== ANIMATION =====
    private var animationTime = 0f                         // Th·ªùi gian ƒë·ªÉ t√≠nh animation
    private var lastUpdateTime = 0L                        // Th·ªùi gian l·∫ßn cu·ªëi update animation

    init {
        initGame()
    }

    /**
     * üîß Kh·ªüi t·∫°o game
     * Setup c√°c listener ƒë·ªÉ c√°c component c√≥ th·ªÉ giao ti·∫øp v·ªõi nhau
     */
    private fun initGame() {
        // Setup listeners ƒë·ªÉ t·∫°o communication gi·ªØa c√°c component
        gameLogic.setGameStateListener(this)        // GameView l·∫Øng nghe thay ƒë·ªïi t·ª´ GameLogic
        inputHandler.setPlayerMoveListener(this)    // GameView l·∫Øng nghe input t·ª´ InputHandler
    }

    // ===== PUBLIC API METHODS =====
    // C√°c method public ƒë·ªÉ Activity/Fragment c√≥ th·ªÉ ƒëi·ªÅu khi·ªÉn game

    fun loadLevel(levelId: Int) {
        gameLogic.loadLevel(levelId)
        // ‚≠ê LOAD MONSTERS t·ª´ level data
        monsterSystem.clearMonsters()  // X√≥a monsters c≈©

        val level = gameLogic.getCurrentLevel()
        level?.monsters?.forEachIndexed { index, monsterData ->
            val monsterId = "monster_${levelId}_${index}"
            val monster = monsterSystem.createMonsterFromData(monsterData, monsterId)
            monsterSystem.addMonster(monster)

            println("üéÆ Loaded monster: ${monsterId} type=${monsterData.type} at (${monsterData.startRow}, ${monsterData.startColumn})")
        }
    }

    fun setBackgroundImage(resourceId: Int, scrollType: BackgroundManager.BackgroundScrollType = BackgroundManager.BackgroundScrollType.PARALLAX_HORIZONTAL) {
        backgroundManager.setBackgroundImage(resourceId, scrollType)
        gameStateChanged = true  // B√°o c·∫ßn redraw
    }
    

    fun setBackgroundImageFromAssets(fileName: String, scrollType: BackgroundManager.BackgroundScrollType = BackgroundManager.BackgroundScrollType.PARALLAX_HORIZONTAL) {
        backgroundManager.setBackgroundImageFromAssets(fileName, scrollType)
        gameStateChanged = true  // B√°o c·∫ßn redraw
    }
    
    /**
     * ‚ö° ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô animation background
     * @param speed T·ªëc ƒë·ªô (VD: 0.5 = ch·∫≠m, 2.0 = nhanh)
     */
    fun setBackgroundSpeed(speed: Float) {
        backgroundManager.setBackgroundSpeed(speed)
    }
    
    /**
     * üîÑ Thay ƒë·ªïi ki·ªÉu animation background
     * @param type Lo·∫°i animation (PARALLAX, ZOOM, ROTATING, ...)
     */
    fun setBackgroundScrollType(type: BackgroundManager.BackgroundScrollType) {
        backgroundManager.setBackgroundScrollType(type)
        gameStateChanged = true  // B√°o c·∫ßn redraw
    }

    fun pauseBackgroundAnimation() {
        backgroundManager.pauseBackgroundAnimation()
    }

    fun resumeBackgroundAnimation(speed: Float = 0.5f) {
        backgroundManager.resumeBackgroundAnimation(speed)
    }


    fun startGame() {
        if (!isGameRunning) {
            isGameRunning = true
            gameThread = GameThread()   // T·∫°o thread m·ªõi
            gameThread?.start()         // B·∫Øt ƒë·∫ßu game loop
        }
    }


    fun stopGame() {
        isGameRunning = false           // Set flag ƒë·ªÉ thread tho√°t loop
        gameThread?.interrupt()         // Interrupt thread
        try {
            gameThread?.join()          // ƒê·ª£i thread k·∫øt th√∫c
        } catch (e: InterruptedException) {
            Thread.currentThread().interrupt()
        }
        gameThread = null               // Clean up
    }


    fun pauseGame() {
        isGameRunning = false
    }

    fun resumeGame() {
        if (!isGameRunning) {
            startGame()
        }
    }

    /**
     * üîÑ GameThread - Thread ch·∫°y game loop
     * 
     * ƒê√¢y l√† "tr√°i tim" c·ªßa game, ch·∫°y li√™n t·ª•c v·ªõi 60 FPS:
     * 1. Update game logic
     * 2. Check n·∫øu c·∫ßn redraw ‚Üí g·ªçi invalidate()
     * 3. Sleep ƒë·ªÉ maintain 60 FPS
     */
    private inner class GameThread : Thread() {
        override fun run() {
            while (isGameRunning && !isInterrupted) {
                try {
                    val startTime = System.currentTimeMillis()
                    
                    // 1. Update game (animation, logic, etc.)
                    updateGame()
                    
                    // 2. N·∫øu c√≥ thay ƒë·ªïi ‚Üí trigger redraw tr√™n UI thread
                    if (gameStateChanged) {
                        post { invalidate() }        // Schedule onDraw() tr√™n UI thread
                        gameStateChanged = false     // Reset flag
                    }

                    // 3. Sleep ƒë·ªÉ maintain 60 FPS (16.67ms/frame)
                    val frameTime = System.currentTimeMillis() - startTime
                    if (frameTime < frameTimeMillis) {
                        sleep(frameTimeMillis - frameTime)  // Sleep ph·∫ßn th·ªùi gian c√≤n l·∫°i
                    }
                } catch (e: InterruptedException) {
                    break  // Thread b·ªã interrupt ‚Üí tho√°t loop
                }
            }
        }
    }

    /**
     * üîÑ Update game m·ªói frame
     * 
     * Method n√†y ƒë∆∞·ª£c g·ªçi 60 l·∫ßn/gi√¢y t·ª´ GameThread:
     * 1. T√≠nh FPS ƒë·ªÉ debug
     * 2. Update animation time
     * 3. Update background animation
     */
    private fun updateGame() {
        // ===== DEBUG FPS =====
        frameCount++  // ƒê·∫øm s·ªë frame
        val currentTime = System.currentTimeMillis()

        // M·ªói gi√¢y in ra FPS ƒë·ªÉ debug
        if (currentTime - lastFPSTime >= 1000) {
            println("üéÆ Game FPS: $frameCount")  // Should be ~60
            frameCount = 0
            lastFPSTime = currentTime
        }

        val rawDeltaTime = if(lastUpdateTime==0L){
            0.016f
        }else{
            (currentTime - lastUpdateTime).toFloat() / 1000f
        }
        lastUpdateTime = currentTime

        // ƒê·∫£m b·∫£o deltaTime h·ª£p l√Ω
        val deltaTime = rawDeltaTime.coerceIn(0.01f, 0.1f)

        // ===== UPDATE ANIMATION =====
        animationTime = currentTime.toFloat()  // Th·ªùi gian cho background animation

        // update monsters
        val (playerX, playerY) = gameLogic.getPlayerPosition()
        monsterSystem.updateMonsters(deltaTime, playerX, playerY, gameLogic.getMap())

        //check collision between player and monsters
        if(monsterSystem.checkPlayerCollision(playerX, playerY)){
            onPlayerDied()
        }

        // Update bullets
        // Update v·ªã tr√≠ bullets v√† cleanup
        val tileSize = gameRenderer.calculateTileSize(gameLogic.getMap()).toFloat()
        val (offsetX, offsetY) = gameRenderer.calculateBoardOffset(gameLogic.getMap())
        bulletSystem.updateBullets(deltaTime, width.toFloat(), height.toFloat(), gameLogic.getMap(), tileSize, offsetX, offsetY)

        // ===== CHECK BULLET COLLISIONS =====
        // Ki·ªÉm tra bullets c√≥ ch·∫°m monsters kh√¥ng
        val monsterPositions = monsterSystem.getActiveMonsters().map {
            Pair(it.currentY, it.currentX)  // ƒê·∫£o ng∆∞·ª£c coordinate nh∆∞ trong drawMonsters
        }

        val collisions = bulletSystem.checkCollisions(monsterPositions)
        collisions.forEach { (bullet, monsterIndex) ->
            // TODO: X·ª≠ l√Ω khi bullet ch·∫°m monster
            // - TƒÉng ƒëi·ªÉm
            // - Hi·ªáu ·ª©ng visual
            // - Sound effect
            println("üéØ Bullet destroyed monster $monsterIndex!")
        }

        val bulletsHitWall = bulletSystem.getBulletsHitWall()
        if (bulletsHitWall.isNotEmpty()) {
            soundManager.playSound("bullet_wall")
            println("üí• ${bulletsHitWall.size} bullets hit wall!")
        }

        // Update background animation v√† check c·∫ßn redraw kh√¥ng
        if (backgroundManager.updateAnimation()) {
            gameStateChanged = true  // Background c√≥ animation ‚Üí c·∫ßn redraw
        }

        // Monsters c≈©ng c·∫ßn redraw
        if (monsterSystem.getActiveMonsters().isNotEmpty()) {
            gameStateChanged = true
        }
    }

    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)
        
        // Th√¥ng b√°o k√≠ch th∆∞·ªõc m·ªõi cho c√°c component
        gameRenderer.setScreenSize(w, h)       // ƒê·ªÉ t√≠nh to√°n tile size v√† layout
        backgroundManager.setScreenSize(w, h)  // ƒê·ªÉ scale background cho ph√π h·ª£p
    }

    /**
     * üé® V·∫Ω to√†n b·ªô game l√™n Canvas
     * 
     * Method n√†y ƒë∆∞·ª£c g·ªçi m·ªói khi c·∫ßn redraw (khi g·ªçi invalidate()).
     * Th·ª© t·ª± v·∫Ω r·∫•t quan tr·ªçng: Background ‚Üí Game Board ‚Üí UI
     * 
     * @param canvas Canvas ƒë·ªÉ v·∫Ω l√™n
     */
    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)

        // 1. üé® V·∫Ω background tr∆∞·ªõc (n·ªÅn)
        backgroundManager.drawBackground(canvas, animationTime)

        // 2. üéÆ V·∫Ω game board (tiles: wall, box, player, goal)
        //    Ch·ªâ v·∫Ω n·∫øu ƒë√£ load level
        if (!gameLogic.isMapEmpty()) {
            val monsters = monsterSystem.getActiveMonsters()
            gameRenderer.drawGameBoard(canvas, gameLogic.getMap(), gameLogic.getPlayerDirection(), monsters)
        }

        // V·∫Ω bullets
        val activeBullets = bulletSystem.getActiveBullets()
        gameRenderer.drawBullets(canvas, activeBullets)
        
        // 3. üñºÔ∏è V·∫Ω UI elements cu·ªëi c√πng (tr√™n c√πng)
        //    Title, instructions, score, etc.
        gameRenderer.drawGameUI(canvas)
    }


    override fun onTouchEvent(event: MotionEvent): Boolean {
        // üîÑ DELEGATE CHO INPUT HANDLER TR∆Ø·ªöC
        val inputHandled = inputHandler.handleTouchEvent(event)

        // N·∫øu InputHandler ƒë√£ x·ª≠ l√Ω (swipe), return lu√¥n
        if (inputHandled) {
            return true
        }

        // N·∫øu InputHandler kh√¥ng x·ª≠ l√Ω (tap), th√¨ b·∫Øn ƒë·∫°n
        when (event.action) {
            MotionEvent.ACTION_UP -> {
                // üéØ B·∫ÆN ƒê·∫†N THEO H∆Ø·ªöNG PLAYER

                // 1Ô∏è‚É£ L·∫•y v·ªã tr√≠ player tr√™n grid
                val playerPos = gameLogic.getPlayerPosition()
                val playerDirection = gameLogic.getPlayerDirection()

                // 2Ô∏è‚É£ Convert grid position ‚Üí screen position
                val tileSize = gameRenderer.calculateTileSize(gameLogic.getMap())
                val (offsetX, offsetY) = gameRenderer.calculateBoardOffset(gameLogic.getMap())

                // 3Ô∏è‚É£ T√≠nh v·ªã tr√≠ player tr√™n m√†n h√¨nh (CENTER c·ªßa tile)
                val playerScreenX = offsetX + playerPos.second * tileSize + tileSize/2  // Center X
                val playerScreenY = offsetY + playerPos.first * tileSize + tileSize/2   // Center Y

                println("üéØ Player position: Grid(${playerPos.first}, ${playerPos.second}) -> Screen(${playerScreenX.toInt()}, ${playerScreenY.toInt()})")

                // 4Ô∏è‚É£ T√≠nh target position d·ª±a tr√™n h∆∞·ªõng player (TƒÇNG KHO·∫¢NG C√ÅCH!)
                val targetX = when (playerDirection) {
                    PlayerDirection.LEFT -> playerScreenX - 2000f    // B·∫Øn sang tr√°i xa h∆°n
                    PlayerDirection.RIGHT -> playerScreenX + 2000f   // B·∫Øn sang ph·∫£i xa h∆°n
                    PlayerDirection.UP -> playerScreenX             // Gi·ªØ nguy√™n X
                    PlayerDirection.DOWN -> playerScreenX           // Gi·ªØ nguy√™n X
                }

                val targetY = when (playerDirection) {
                    PlayerDirection.LEFT -> playerScreenY           // Gi·ªØ nguy√™n Y
                    PlayerDirection.RIGHT -> playerScreenY          // Gi·ªØ nguy√™n Y
                    PlayerDirection.UP -> playerScreenY - 800f      // B·∫Øn l√™n tr√™n xa h∆°n
                    PlayerDirection.DOWN -> playerScreenY + 800f    // B·∫Øn xu·ªëng d∆∞·ªõi xa h∆°n
                }

                // 5Ô∏è‚É£ B·∫Øn ƒë·∫°n theo h∆∞·ªõng player
                bulletSystem.addBullet(playerScreenX, playerScreenY, targetX, targetY)

                // üÜï TH√äM √ÇM THANH B·∫ÆN ƒê·∫†N
                soundManager.playSound("shoot")
                println("üéØ Player fired bullet in direction: $playerDirection")

                return true
            }
        }

        return super.onTouchEvent(event)
    }


    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        startGame()  // B·∫Øt ƒë·∫ßu game loop
    }

    override fun onDetachedFromWindow() {
        super.onDetachedFromWindow()
        stopGame()   // D·ª´ng game loop v√† clean up
        soundManager.cleanup()
    }

    // ===== CALLBACK IMPLEMENTATIONS =====
    
    /**
     * üéØ GameLogic.GameStateListener - L·∫Øng nghe thay ƒë·ªïi t·ª´ GameLogic
     */

    /**
     * üîÑ ƒê∆∞·ª£c g·ªçi khi game state thay ƒë·ªïi
     * VD: Player di chuy·ªÉn, box ƒë∆∞·ª£c ƒë·∫©y, level reset
     */
    override fun onGameStateChanged() {
        gameStateChanged = true // B√°o c·∫ßn redraw
        
        if (!isGameRunning) {
            post { invalidate() }
        }
        // N·∫øu game thread ƒëang ch·∫°y ‚Üí n√≥ s·∫Ω t·ª± ƒë·ªông redraw
    }


    override fun onGameWon() {
        isGameRunning = false  // D·ª´ng game loop
        post {
            // TODO: Hi·ªÉn th·ªã th√¥ng b√°o chi·∫øn th·∫Øng
            // Toast.makeText(context, "üéâ You Win!", Toast.LENGTH_LONG).show()
            // Ho·∫∑c show dialog chuy·ªÉn level ti·∫øp theo
        }
    }

    override fun onPlayerMove(dx: Int, dy: Int) {
        var moved = gameLogic.movePlayer(dx, dy)  // Delegate cho GameLogic x·ª≠ l√Ω
        if (moved) {
            // üÜï DI CHUY·ªÇN TH√ÄNH C√îNG - Ph√°t √¢m thanh di chuy·ªÉn
            soundManager.playSound("move")
        } else {
            // üÜï ƒê·∫¨P V√ÄO T∆Ø·ªúNG - Ph√°t √¢m thanh bump
            soundManager.playSound("bump_wall")
        }
    }

    fun resetLevel() {
        gameLogic.resetLevel()
    }

    fun isGameWon(): Boolean = gameLogic.isGameWon()
    

    fun getProgressPercentage(): Float = gameLogic.getProgressPercentage()

    fun getCurrentLevel() = gameLogic.getCurrentLevel()
    /**
     * üíÄ X·ª≠ l√Ω khi player ch·∫øt (ch·∫°m monster)
     */
    private fun onPlayerDied() {
        isGameRunning = false  // D·ª´ng game loop
        post {
            // TODO: Hi·ªÉn th·ªã Game Over dialog
            println("üíÄ GAME OVER! Player touched monster!")

            // T·∫°m th·ªùi restart level
            val levelId = gameLogic.getCurrentLevel()?.id ?: 1
            loadLevel(levelId)
        startGame()
    }
    }

    // Th√™m v√†o cu·ªëi file GameView.kt
    fun setSoundMuted(muted: Boolean) {
        soundManager.setMuted(muted)
    }

    fun isSoundMuted(): Boolean = soundManager.isMuted()
}